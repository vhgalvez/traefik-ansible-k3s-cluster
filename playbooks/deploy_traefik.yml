# playbooks/deploy_traefik.yml
# ğŸ” Fase 1 y ğŸš€ Fase 2 - Despliegue completo sin PVC
---
# ğŸ” Fase 1a: Generar Secret sellado para el dashboard de Traefik
- name: ğŸ” Generar Secret sellado para Traefik Dashboard
  import_playbook: generate_traefik_secrets.yml

# ğŸ” Fase 1b: Generar certificados autofirmados (si no existen)
- name: ğŸ” Generar certificados autofirmados
  import_playbook: generate_certs.yml

# ğŸ” Fase 1c: Crear Secret TLS interno a partir de los certificados
- name: ğŸ” Crear Secret TLS interno
  import_playbook: generate_internal_tls_secrets.yml

# ğŸ” Fase 1d: Aplicar Middlewares e IngressRoutes
- name: ğŸ” Aplicar Middlewares & IngressRoutes
  import_playbook: apply_ingress_and_middlewares.yml

# ğŸš€ Fase 2: Instalar Traefik con Helm (modo sin PVC)
- name: ğŸš€ Instalar Traefik con Helm
  import_playbook: install_traefik.yml

# âœ… Fase 2: VerificaciÃ³n post-instalaciÃ³n
- name: âœ… Verificar despliegue de Traefik
  hosts: localhost
  gather_facts: false

  vars:
    kubeconfig_path: "/home/victory/.kube/config"
    kubectl_bin_path: "/usr/local/bin/kubectl"

  vars_files:
    - ../vars/main.yml

  tasks:
    - name: â³ Esperar a que el pod de Traefik estÃ© listo
      shell: >
        {{ kubectl_bin_path }} -n kube-system wait --for=condition=Ready pod
        -l app.kubernetes.io/name=traefik --timeout=90s
      environment:
        KUBECONFIG: "{{ kubeconfig_path }}"
      register: wait_output
      changed_when: false

    - name: ğŸ” Verificar estado de pods de Traefik
      shell: >
        {{ kubectl_bin_path }} get pods -n kube-system -l app.kubernetes.io/name=traefik
      environment:
        KUBECONFIG: "{{ kubeconfig_path }}"
      register: traefik_status

    - name: ğŸ§¾ Mostrar estado de pods de Traefik
      debug:
        var: traefik_status.stdout_lines

    - name: ğŸŒ Verificar acceso al Dashboard (modo tolerante)
      shell: |
        curl -k -u {{ traefik_auth_user }}:{{ traefik_auth_pass }} https://traefik.socialdevs.site/dashboard/ --max-time 5 --silent --output /dev/null --write-out '%{http_code}'
      register: dashboard_status
      failed_when: dashboard_status.stdout not in ["200", "301", "302"]
      ignore_errors: true